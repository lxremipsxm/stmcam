# Camera with STM32 and OV7670

## Goals

This project is entirely for my learning. At UMass Amherst, I took a class, ECE231 - Introduction to Embedded Systems, which had me rapt with attention. Well, to be more specific, their lectures were alright, but the course matter was so much more intriguing than the kind of coding I was used to doing with the Arduino UNO. It was about the first time I heard of baremetal coding, but it shattered my understanding of embedded systems at the time. During the semester, I loved the course so much that I was doing my assigments weeks ahead of time (thanks to the professor uploading everything onto github).

Towards the end of the semester, I really wanted to MAKE something. I had all this potentially useful knowledge, but I wanted to expand on it. So here I am, making a camera. It's supposed to be a basic camera, with all the flexibility that a camera module library allows, with minimal features. However, instead of using an IDE with readymade ways to set GPIO pins and PWM generation, I wanted to build something by accessing and modifying registers directly. I wanted to create makefiles and flash my code directly to the CPU on board whatever board I was planning to use. After a couple hours of research, I solidified what I wanted to create and with what components. The following is my journey through this project using whatever tools I can find online. And in order to make sure everything sticks, I will avoid using LLMs unless absolutely necessary. 

## Getting Started

I wanted to start out by creating a simple UART script to flash to my STM32. This would give me an introduction to the compilation tools I would need, help me create a simple user-defined UART library I could then use to debug later on, and also give me an idea of how my makefiles should look for future updates. I also will avoid installing the STM32Cube IDE, since I want to work more bare-metal, and try to handle memory and registers myself.


### Progression

#### arm-none-eabi toolchain - 5/20/25

Downloaded the `.exe` file off the ARM official downloads page. Took incredibly long despite being only 203MB. 

Installed with no issues. Also added to PATH and verified using `arm-none-eabi-gcc --version`.


#### Open On-Chip Debugger (OpenOCD)

Downloaded and installed, no hiccups. Added to PATH.

#### ST-Link - 5/25/25

Installed with no issues.

#### Dependencies

I grabbed a couple files from the [ST electronics github repository](https://github.com/STMicroelectronics/STM32CubeF4) in order to satisfy dependencies and simplify working with registers on the STM32, and then rearranged my project directory so that it’s more organized. The file organization will look about the same for different stages of the project, give or take some additional libraries, but it makes it easier to work with since I won’t have to modify the makefile much at all for most parts of the project.

So far, the files are organized like this:

```
Camera/

	Test_code/

		inc/

		src/

		startup/

		system/

		linker/

		makefile
```


`startup/` contains `startup_stm32f401xe.s`. This preps the board for running the main code

`system/` contains `system_stm32f4xx.c`. It defines the clock source and vector table location.

`linker/` contains the linker file, `linker.ld`. I have no experience whatsoever with linkers, so this one was generated by ChatGPT.

`src/` contains my source code, `main.c`, and library files, which I will put in a subdirectory called `lib/`

`inc/` contains `stm32f401xe.h` and the following, which are dependencies required by `stm32f401xe.h`.

![File Structure](images/inc_filestructure.png)

Most of the issues I had in this part of the project were due to missing dependencies, which I combed through the STM32CubeF4 repo for, so I restarted several times, trying different organizations that I thought would work. Eventually, I settled on this, and my code compiled successfully when I ran `make`, so I stuck with it. 

#### Installing ST-Link Driver
When I tried to run `make flash`, I got back errors claiming that there were no “st-link devices” available. I found out that I needed to install a st-link to USB driver, for which I used [Zadig](https://github.com/pbatard/libwdi/wiki/Zadig) to satisfy. Now I was able to flash my code to the board successfully. The final step in getting the project off the ground is to check if I can use register names and bitwise operations to operate the LEDs on-board, just to see if the dependencies and their arrangement are functional.



### Concepts Learned

#### Linkers

A linker file helps create an executable from the compiled `.o` files a makefile produces. In a nutshell, a linker takes all the object files a makefile creates and “links” them into one executable. More elaborately, it resolves symbols (variable names), arranges memory layout (where each piece of code goes) and produces a `.elf` or `.bin` file. 

Linkers are needed in microcontrollers since there is no OS handling the executables and mapping it in memory.

A typical linker script has the following skeleton:
+   Memory regions: Where we define the start of Flash memory and RAM and their lengths
+   Sections: Defines sections such as `.text` for code, `.data` for uninitialized variables, `.bss` for zeroed variables, and `.isr_vector` for the interrupt vector table.

My `linker.ld` file modifies the Memory regions according to the size of flash and RAM on my Nucleo STM32F401RE. It additionally has an entry point demarcated by `ENTRY(Reset_Handler)`, which indicates to the CPU which address to jump to when the board is reset.

---



## Setting up Communication and Delays

### Progression

#### Setting up USART communication - 5/29/25

From the documentation and a forum online, I discovered that USART2 allows communication through USB via ST-Link’s VCP (Virtual COM Port). I worked on setting up UART the entirety of this week (5/26 to 5/30). I could’ve finished it in an hour, realistically, but I really tried to delve into how the code should be structured and how to work with STM32 bare metal, since it ended up being vastly different from what I learnt using `avr/io.h` for ATMega328p. 

Eventually, I successfully created my `uart.c` and `uart.h` files for use in later iterations of my software.

#### Setting up delays - 5/30/25
This is more of a side learning endeavor, since I didn’t fully pay attention to timers and counters in my embedded systems class. I tried using a simple `__asm__(“nop”)` function (perform nothing this clock cycle) in a `while` loop for delays, but that proved to be increasingly inaccurate the larger the delay got, considering using a decrementing count variable in a `while` loop itself uses a couple clock cycles.

I set out to use a TIM-based delay library, partially so that I could learn how timers work in practice. 

I later successfully created TIM-based delays. It’s very simple, but my primary issue with implementing this was understanding how the prescaler works. The peripheral buses (APBs) on STM32F401RE have their own clocks, and the timer I was using, TIM2, has a doubled clock frequency compared to these (up to 84MHz). Initially, I set the prescaler register to the divisor assuming the original 16MHz clock was at work, which was wrong, rendering my delay test using PuTTY and UART being significantly off the mark (sample text with delays set for one second would take 3-5 seconds to show up).


### Challenges

One of the biggest issues I overcame here was understanding how to read the documentation and implement it directly in code. The instructions in the STM32F4 reference manual were a little vague, and I didn’t realize how much I would have to depend on `stm32f401xe.h` (in my inc/ folder) in order to implement my code (considering it was full of constants and structs I would need to activate peripherals).  Additionally, as I tried to work my way through this, I didn’t realize that the reference manual was “cumulative” in that I would need to read pretty much everything preceding the current topic of interest to code anything related to it. For example, I directly jumped to the instructions to USART. Only later in the process of setting up UART did I notice that I needed to explicitly enable the clock for that peripheral: I mistakenly assumed the processor would automatically allocate the main 16MHz clock for peripherals.


### Concepts Learned

#### Peripherals Buses on STM32F4xx

When trying to activate the clocks for GPIOA and USART2, I learned that the clocks for the buses these peripherals are attached to need to be activated first. The buses form a heirarchy, where AHB1 (Advanced High-Performance Bus) connects memory and high-speed peripherals, such as GPIO registers. AHB1 is then connected to two APBs, or Advanced Peripheral Buses via AHB-APB bridges. The APBs are referred to as APB1 and APB2, where APB2 can activate higher speed peripherals. 

Note: After further reading I found that there is another High Performance Bus, AHB2, which has one peripheral on it on this chip: a USB OTG FS peripheral (which I assume is used more in STM32Cube) that allows communication between a USB host and the board.

The AHB1 struct in `stm32f401xe.h` has a member called RCC, which is the Reset and Clock Control peripheral that enables/disables/resets the clock on different peripherals. For example, `RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;` enables the clock for the GPIOA peripheral. 


#### Using the Reference Manual and Associated Headers

I learnt the above by reading the [ST electronics reference manual](chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://www.st.com/resource/en/reference_manual/rm0368-stm32f401xbc-and-stm32f401xde-advanced-armbased-32bit-mcus-stmicroelectronics.pdf). Like I said earlier, reading this involves reading all of the prerequisite sections first, like reading the RCC section before getting to the general-purpose timer section/USART section. However, implementing the contents of the RF involve scouring `stm32f401xe.h` for the right `typedef`, and then finding the correct member to set the register bits as required. Additionally, since STM32 has 32-bit registers rather than 8-bit registers (which I am more experienced with), the bitwise operations require a bit more thought than simple left or right shifts.

---

## OV7670

### Progression

#### Finding the right library - 6/8/25

It's been about a week, and I've been trying to find the best ov7670 libraries for my purposes. The last week, I've been trying to figure out [this library](https://github.com/adafruit/Adafruit_OV7670/blob/master/src/ov7670.c) by Adafruit. The sole issue with this is that it has been developed with so much flexibility that any architecture should be able to run it. However, this also means customizing it myself, which I am unsure of how I should start, or where to start. There are three external C functions I need to provide specific to my architecture, `void OV7670_print(char *str);`, `int OV7670_read_register(void *platform, uint8_t reg);`, and `void OV7670_write_register(void *platform, uint8_t reg, uint8_t value);`. I will find some forums online to see what direction people have taken.

#### Customizing Adafruit's OV7670 library - 6/10/25

After scrutinizing the aforementioned Adafruit library, I found that the comments suggested taking a look at the library intended for use by the Arduino IDE, where I found examples of the implementations of the aforementioned methods. The print method is pretty straightforward, since I already have a USART library, but the other two use `Wire.h`, which means I will need to work out how to implement them. Apart from that, I've realized that despite the library being a little more platform agnostic than most others, it is still heavily tailored towards Arduino/SAMD5 use, which means I will need to tweak the `arch/` files (`arch/samd51.c` and its header file, both in the linked repository). The code is extremely flexible, which I don't really require (for example, one function, `OV7670_arch_begin()` sets up a timer for the `XCLK` pin, but assumes that the user will choose any timer on board, so there are a lot of `ifdef`s. I will only need one timer definition for `XCLK`). I'll trim down the code + add the required functionality as I need and then begin testing the module.

##### 6/11/25

I discovered why the library is not developed fully for STM32 use. Or at least my board, which does not have a Parallel Capture Controller. In order to capture at the maximum possible frame rate, I need parallel capture configured. For this, it's recommended that I use external high-speed FIFO RAM module, which I will have to buy, but I cannot find anywhere. I will have to resort to serial capture. My initial plan was to only have a picture functionality, and maybe image pre-/post-processing so I will stick to that. The idea is that I use a microSD to construct the image line-by-line, and simultaneously display it on an LCD screen using interrupts to make the process more efficient.

Anyways, I am currently trying to map out how to build the functions I need in `ov7670.c`. Arduino has a simple GPIO number system that abstracts away the Port B, C, and D names and numbers, which probably makes it easier to code baremetal. I'll look online and in the `stm32f401xe.h` file to see if I can find something similar that will benefit me in this way. I do see D0 to D15 and A0 to A5. I will need to look a little deeper to see if any of them are being used in my other libraries, such as pin PA_2, which is currently being used for USART2 (Alternate function `USART_TX`). I similarly need to avoid using up all the pins that are SPI enabled, as I need them for the LCD screen; I'll dedicate pins `{PB_3, PB_4, PB_5}` for LCD SPI. 

Also, for reference, I'm using the images on [this site](https://os.mbed.com/platforms/ST-Nucleo-F401RE/) to make these decisions. Speaking of, I found a link on this site that has a pin map library, which I might use, for which I might need to include some additional dependencies. 

If that results in too many changes, I'll just create my own numerical pin map, with just the pins that I need. 

Update: I've looked through the code for ov7670, and it's clear I only ever need to set two pins to output and write `LOW` or `HIGH` to them. This means I can pretty much just hardcode setting the pins to output, and the parameter `pin` can just be a sort of boolean with two options: reset or enable.

##### 8/21/25

I've added the timer initialization to the `OV7670_arch_begin()`. I've skipped the transfer initialization for now, but I will need to decide a good serial protocol to provide communication between the camera and the MCU that will facilitate the best frame rate, especially considering I am trying to sneak an LCD display in there.

I believe it makes best sense to leave this library as-is for now, and work on getting the SD slot to work with the board. That way, I can have everything ready for when I want to set up the capture function.


##### 9/4/25 

After further research, I've concluded that I don't even need serial transfer: instead of DCMI (which Nucleo F401 does not have), I can emulate parallel capture with GPIO+DMA(Direct Memory Access) peripherals. In order to implement this, I need to read the documentation fully to ensure I understand entirely how DMA works. I've found an Application Note by ST Microelectronics titled AN4666, "Parallel Synchronous Transmission". I'll read this and then implement it before I move on to the SD card. This means I can set up DMA in the `OV7670_arch_begin()` method. Then, I'll use the original author's logic to implement a DMA version of `OV7670_capture()`.

##### 9/25/25

It's been about two weeks since my last update. So far, I've made a ton of progress with DMA. Right now, I have implemented the `OV7670_arch_begin()` method using two timers (this is not a robust setup: it's hard coded to TIM1 and TIM3). TIM1 is the clock on which the camera runs; it is the 20 MHz signal that is inputted into the `XCLK` pin. TIM3, on the other hand, is triggered by the pixel clock `PCLK` coming off the camera, which indicates when new data is available for capture over the 8 data pins. DMA is triggered by rising edges in the signal on TIM3, which is when it captures data. DMA1 is set to double-buffer mode, which prevents data from accidentally getting erased/lost when new data is captured from the data pins. Additionally, DMA1 is set to capture data off `PORTB[7:0]`. This is where the data pins will be connected. 

I've also implemented *some* of the `OV7670_capture()` method. Right now, all I need to get that to work is to wire up the camera, using USART to check if the clocks are triggering DMA by checking relevant flags (I haven't figured out which ones yet), and then commenting out USART. Once I wire up a display, I can try using SPI to transfer data from memory to the screen and seeing if anything pops up.


##### 10/9/25

I've completed the capture function, but haven't tested it yet. In order to do that, I have to first implement the extern functions that the Adafruit repository author suggests. I need to do this over I2C. For this, I'll decide a SCL and SDA line on the Nucleo. I may also create an I2C library, but I can probably just implement it directly in the `OV7670_externs.c` module I have set up.

I2C has two modes: Standard and Filtered. I will use filtered as I want to use a higher clock speed for faster transfers. 


##### 10/15/25

I added the I2C library and included them in the `ov7670_externs.c` file. I used an LLM to verify if my DMA function was good, but apparently it is not, so I will re-implement it by looking through the documentation more thoroughly. In fact, I will read the entire section, not just what looks like it concerns me, and take notes, then apply whatever I've gathered from there in my function. I've also been informed by the LLM that using circular mode (where `NDTR` reloads to the starting mode every time it reaches 0) is better for my library as it avoids having to manually reload `NDTR` every time a capture is complete, therefore avoiding any missing data from the tight timing windows I need the MCU to maneuver around.

As a result, I've cleared out `OV7670_capture()` and will make heavy revisions to `OV7670_arch_begin()`. In the meantime, I will also try and acquire a TFT monitor to display and/or debug the output coming from the camera and whether or not it is actually capturing anything at all.

### Challenges

I learnt an even more important fact about the documentation that I wasn't aware of, even though it was quite blatant: the bit locations and register names and functions are displayed in full detail, which makes things incredibly easy to set up. For example, I was struggling to compile all the information about the registers that I was googling when setting up the timer to go into the XCLK pin (TIM1 Advanced Timer). Turns out, the whole thing is right there in the documentation: at the end of every chapter, there's a section dedicated to register bit locations and names that I was skipping over. After I discovered that, setting up TIM1 output on PA8 was a piece of cake.
 


